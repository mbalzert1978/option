import typing

from result import Result

T = typing.TypeVar("T")
E = typing.TypeVar("E")
N = typing.TypeVar("N")
U = typing.TypeVar("U")
F = typing.TypeVar("F")
P = typing.ParamSpec("P")

class OptionError(Exception):
    """Base result error."""

class UnwrapFailedError(OptionError):
    """Unwrap failed error."""

class TransposeError(OptionError):
    """Transpose failed error."""

class Option(typing.Generic[T, N]):
    def and_then(self, f: typing.Callable[[T], Option[U, N]]) -> Option[U, N]: ...
    def expect(self, msg: str) -> T: ...
    def filter(self, predicate: typing.Callable[[T], bool]) -> Option[T, N]: ...
    def is_none(self) -> bool: ...
    def is_some(self) -> bool: ...
    def is_some_and(self, f: typing.Callable[[T], bool]) -> bool: ...
    def map(self, f: typing.Callable[[T], U]) -> Option[U, N]: ...
    def map_or(self, default: U, f: typing.Callable[[T], U]) -> U: ...
    def map_or_else(
        self, default: typing.Callable[[], U], f: typing.Callable[[T], U]
    ) -> U: ...
    def ok_or(self, err: E) -> Result[T, E]: ...
    def ok_or_else(self, err: typing.Callable[[], E]) -> Result[T, E]: ...
    def or_(self, optb: Option[T, N]) -> Option[T, N]: ...
    def or_else(self, f: typing.Callable[[], Option[T, N]]) -> Option[T, N]: ...
    def transpose(self) -> Result[Option[T, N], E]: ...
    def unwrap(self) -> T: ...
    def unwrap_or(self, default: T) -> T: ...
    def unwrap_or_else(self, f: typing.Callable[[], T]) -> T: ...
    @staticmethod
    def some(value: T) -> Option[T, N]: ...
    @staticmethod
    def null(value: N) -> Option[T, N]: ...
    @staticmethod
    def as_option(fn: typing.Callable[P, T]) -> typing.Callable[P, Option[T, N]]:
        """
        Decorates a function so that it returns a `Optional<T>` instead of `T`.

        # Examples:

        >>> @Result.as_maybe
        >>> def div(a: int, b: int) -> float:
        ...     return a / b
        >>> assert div(10, 2) == 5.0
        >>> assert div(10, 0) is None
        """

class Some(Option[T, typing.Any]):
    def __iter__(self) -> typing.Iterator[T | None]: ...
    def __repr__(self) -> str: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __init__(self, inner_value: T) -> None: ...

class Null(Option[typing.Any, N]):
    def __iter__(self) -> typing.Iterator[T | None]: ...
    def __repr__(self) -> str: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __init__(self, inner_value: T) -> None: ...
